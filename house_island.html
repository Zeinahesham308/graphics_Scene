<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - shaders - ocean</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl ocean
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Water } from 'three/addons/objects/Water.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let container, stats;
        let camera, scene, renderer;
        let controls, water, sun;

        init();

        function init() {
            container = document.getElementById('container');

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 20000);
            camera.position.set(30, 30, 100);

            sun = new THREE.Vector3();

            // Water
            const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
            water = new Water(waterGeometry, {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load('public/waternormals.jpg', function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                }),
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            });
            water.rotation.x = -Math.PI / 2;
            scene.add(water);

            // Skybox
            const sky = new Sky();
            sky.scale.setScalar(10000);
            scene.add(sky);

            const skyUniforms = sky.material.uniforms;
            skyUniforms['turbidity'].value = 10;
            skyUniforms['rayleigh'].value = 2;
            skyUniforms['mieCoefficient'].value = 0.005;
            skyUniforms['mieDirectionalG'].value = 0.8;

            const parameters = {
                elevation: 2,
                azimuth: 180
            };

            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            const sceneEnv = new THREE.Scene();

            let renderTarget;

            function updateSun() {
                const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
                const theta = THREE.MathUtils.degToRad(parameters.azimuth);

                sun.setFromSphericalCoords(1, phi, theta);

                sky.material.uniforms['sunPosition'].value.copy(sun);
                water.material.uniforms['sunDirection'].value.copy(sun).normalize();

                if (renderTarget !== undefined) renderTarget.dispose();

                sceneEnv.add(sky);
                renderTarget = pmremGenerator.fromScene(sceneEnv);
                scene.add(sky);

                scene.environment = renderTarget.texture;
            }

            updateSun();

            // Load Island and House Models
            const loader = new GLTFLoader();

            // Add helpers for debugging (remove later)
			const axesHelper = new THREE.AxesHelper(10);
			scene.add(axesHelper);
			const gridHelper = new THREE.GridHelper(50, 50);
			scene.add(gridHelper);

            // Load the rock texture
            const textureLoader = new THREE.TextureLoader();
            const rockTexture = textureLoader.load('models/customLocal/island/grass.jpg', function (texture) {
                // Configure wrapping and repeating for the texture
                texture.wrapS = THREE.RepeatWrapping; // Horizontal wrapping
                texture.wrapT = THREE.RepeatWrapping; // Vertical wrapping
                texture.repeat.set(4, 4); // Adjust the repetitions (4x4 is an example; increase as needed)
            });


			// Load Island
			loader.load('models/customLocal/island/plain_land.glb', function (gltf) {
				const island = gltf.scene;
				island.scale.set(1.5, 1.5, 1.5); // Adjust to a reasonable size
				island.position.set(0, -1, 0); // Place slightly above water level
				island.traverse(function (child) {
					if (child.isMesh) {
						child.castShadow = true;
						child.receiveShadow = true;

                    // Apply the rock texture to the material
                    child.material = new THREE.MeshStandardMaterial({
                                    map: rockTexture, // Use the loaded rock texture
                                    roughness: 1, // Matte finish for a natural look
                                    metalness: 0 // Non-metallic
                                    
                                });
					}
				});
				scene.add(island);

				// Load palm tree
				loader.load('models/customLocal/island/tree.glb', function (gltf) {
					const tree = gltf.scene;
					tree.scale.set(0.5, 0.5, 0.5); // Adjust tree size to fit island
					tree.position.set(0, 10, 0); // Position tree on top of the island
					tree.traverse(function (child) {
						if (child.isMesh) {
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					island.add(tree); // Parent the tree to the island
				});

				// Load House
				loader.load('models/customLocal/island/house2.glb', function (gltf) {
					const house = gltf.scene;
					house.scale.set(0.5, 0.5, 0.5); // Adjust house size to fit island
					house.position.set(0, 11, 0); // Position house on top of the island
					house.traverse(function (child) {
						if (child.isMesh) {
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					island.add(house); // Parent the house to the island
				});
			});

			// Add lighting for better visibility
			const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
			scene.add(ambientLight);
			const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
			directionalLight.position.set(10, 10, 10);
			directionalLight.castShadow = true;



          
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.maxPolarAngle = Math.PI * 0.495;
            controls.target.set(0, 10, 0);
            controls.minDistance = 40.0;
            controls.maxDistance = 200.0;
            controls.update();

            stats = new Stats();
            container.appendChild(stats.dom);

            // GUI
            const gui = new GUI();

            const folderSky = gui.addFolder('Sky');
            folderSky.add(parameters, 'elevation', 0, 90, 0.1).onChange(updateSun);
            folderSky.add(parameters, 'azimuth', -180, 180, 0.1).onChange(updateSun);
            folderSky.open();

            const waterUniforms = water.material.uniforms;

            const folderWater = gui.addFolder('Water');
            folderWater.add(waterUniforms.distortionScale, 'value', 0, 8, 0.1).name('distortionScale');
            folderWater.add(waterUniforms.size, 'value', 0.1, 10, 0.1).name('size');
            folderWater.open();

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            render();
            stats.update();
        }

        function render() {
            water.material.uniforms['time'].value += 1.0 / 60.0;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>